{{- /*gotype: main.TemplateData*/ -}}
// Code generated by protoc-gen-fasthttp. DO NOT EDIT.
package {{.Package}}

import (
	"context"

	"github.com/streamdealer/protoc-gen-fasthttp/pkg/interceptor"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"

	"github.com/fasthttp/router"
	"github.com/streamdealer/protoc-gen-fasthttp/pkg/http"
	"github.com/valyala/fasthttp"
)

type {{.ServerName}} interface {
	{{ range .RPCs }}
	{{.RPCName}}(context.Context, *{{.RequestType}}) (*{{.ResponseType}}, error)
	{{- end }}
}

type Unimplemented{{.ServerName}} struct{}

{{- range .RPCs }}
func (Unimplemented{{$.ServerName}}) {{.RPCName}}(context.Context, *{{.RequestType}}) (*{{.ResponseType}}, error) {
	return nil, status.Errorf(codes.Unimplemented, "method {{.RPCName}} not implemented")
}
{{- end }}

func Register{{.ServiceName}}Routes(r *router.Router, impl {{.ServerName}}, interceptors interceptor.Chain) {
	{{- range .RPCs }}
	r.{{.HTTPVerb}}("{{.HTTPPath}}", {{.HandlerName}}(impl, interceptors))
	{{- end }}
}

{{- range .RPCs }}
func {{.HandlerName}}(
	impl {{$.ServerName}},
	interceptors interceptor.Chain,
) fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {
		var req = &{{.RequestType}}{}

		http.ToProto(ctx, req)

		wrapped := func(ctx context.Context, req proto.Message) (proto.Message, error) {
			r, ok := req.(*{{.RequestType}})
			if !ok {
				return nil, status.Errorf(codes.InvalidArgument, "expected *{{.RequestType}}, got %T", req)
			}
			return impl.{{.RPCName}}(ctx, r)
		}

		resp, err := interceptors.Apply()(ctx, req, nil, wrapped)

		http.RespondWith(ctx, resp, err)
	}
}
{{ end }}
